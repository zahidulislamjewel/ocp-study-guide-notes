# Chapter 1: Building Blocks 

## OCP EXAM OBJECTIVES COVERED IN THIS CHAPTER:

### 1. Handling Date, Time, Text, Numeric and Boolean Values

- Use primitives and wrapper classes. 
- Evaluate arithmetic and boolean expressions, using the Math API and by applying precedence rules, type conversions, and casting.

### 2. Using Object-Oriented Concepts in Java

- Declare and instantiate Java objects including nested class objects, and explain the object life-cycle including creation, reassigning references, and garbage collection.
- Understand variable scopes, apply encapsulation, and create immutable objects. Use local variable type inference.

---

**Key commands include the following:**

- `javac`: Converts `.java` source files into `.class` bytecode
- `java`: Executes the program
- `jar`: Packages files together
- `javadoc`: Generates documentation
- `javap`: Decompiles a `.class`

**Building Blocks of Java**

- classes, interfaces, records, enums

**Object**

- An object is a runtime instance of a class in memory. 
- An object is often referred to as an instance since it represents a single representation of the class. 

**State**

- All the various objects of all the different classes represent the state of your program. 

**Reference**

- A reference is a variable (in stack memory) that points to an object (created in heap memory).

**Member of Class**

- Methods
- Fields

*Variables hold the state of the program. And, methods operate on that state*

**Fileds and Methods**

- Method name and parameter types are called method signature.

**Classes and Source Files**

- A top-level type is a data structure that can be defined independently within a source file. 
- Top-level types are `class`, `interface`, `record`, `enum` 

**Writing main method**

- The `main()` method is often called an entry point into the program, because it is the starting point that the JVM looks for when it begins running a new program.
- The bytecode consists of instructions that the JVM knows how to execute.

**Package and Wildcard Import**

- import statement doesn’t bring in child packages, fields, or methods; it imports only classes directly under the current package

*for example, import statement like `import java.util.*` or `java.util.concurrent.*` doesn't import the class `java.util.concurrent.atomic.AtomicInteger`*

Wildcard imports (e.g. `import java.util.*`) have no impact on a Java program's runtime performance. They are purely a compile-time mechanism and the generated bytecode is identical to using explicit, single-class imports. 

There may be a minor impact on compilation time, as the compiler has to search through all the classes in a package to find the ones being used, rather than going directly to a specified class file. 

However, with modern compilers and IDEs, this difference is generally trivial and unnoticeable for most projects. 

**Name Conflicts**

```java
import java.util.*;
import java.sql.*;

public class Conflicts {
    Date date; // name conflict, compilation error
}
```

```java
import java.util.Date;
import java.sql.Date;

public class Conflicts {
    Date date; // ambiguity, compilation error
}
```

**Solution 1: Using explicit import**

Explicit import takes precedence over any wildcards present. Java thinks, *“The programmer really wants me to assume use of the `java.util.Date` class.”* So, the following works,

```java
import java.util.Date;
import java.sql.*;

public class Conflicts {
    Date date; // no name conflict
}
```

**Solution 2: Using fully qualified class name**

```java
// works fine, no abmiguity, no name conflict
public class Conflicts {
   java.util.Date date;
   java.sql.Date sqlDate;
}
```

*Default package is the package with no package name.*

**Compiling and Deifining Classpath**

```bash
javac -d classes packagea/ClassA.java packageb/ClassB.java
java -cp classes packageb.ClassB    # Class Containing the main() method
```

**Creating `.jar`**

```bash
jar -cvf out/test.jar -C classes .
```

**Ordering Elements in Class**

- PIC (Package > Import > Class)
- Fields and methods don't need to maintain oder but have to be inside the class

**Constructors**

- The purpose of a constructor is to initialize fields.

**Code Blocks and Instance Initializer**

The code between the braces (`{}`) (sometimes called “inside the braces” ) is called a code block. Anywhere we see a set of of braces, that is a code block.

Sometimes code blocks are inside a method. These are run when the method is called. 

Other times, code blocks appear outside a method. These are called *instance initializers*. 

While counting instance initializers, we need to keep in mind that they cannot exist inside a method.

**Order of Execution**

- Fields and instance initializer blocks are run in the order in which they appear in the file.
- The constructor runs after all fields and instance initializer blocks have run.

**Data Types**

Eight built in data types (primitive types). They are, `boolean`, `byte`, `short`, `int`, `long`, `float`, `double` and `char`


These eight data types represent the building blocks for Java objects, because all Java objects are just a complex collection of these primitive data types. 

**Primitive Types**

- a primitive is not an object in Java, nor does it represent an object. 
- A primitive is just a single value in memory, such as a number or character.

***Question:** Is String a Primitive?*

***Answer:** No, it is not. That said, String is often mistaken for a ninth primitive because Java includes built-in support for String literals and operators. It’s an object, not a primitive.*

**Properties**

- All of the numeric types are signed and reserve one of their bits to cover a negative range. For example, instead of byte covering 0 to 255 (or even 1 to 256), it actually covers -128 to 127.

***Question:** What is the bit size of boolean?*

***Answer:** It is not specified and is dependent on the JVM where the code is being executed.*

**Signed vs Unsigned: `short` vs `char`**

`short` and `char` are closely related, as both are stored as integral types with the same 16-bit length.

The primary difference is that `short` is signed, which means it splits its range across the positive and negative integers. 

Alternatively, `char` is unsigned, which means its range is strictly positive, including 0.

Often, `short` and `char` values can be cast to one another because the underlying data size is the same. 

**Literal**

When a number is present in the code, it is called a literal. By default, Java assumes we are defining an int value with a numeric literal. 

Octal numbers are prefixed with 0. For example, 017.

Hexadecimal numbers are prefixed with 0x. For example, 0xFF.

Binary numbers are prefixed with 0b. For example, 0b10.

**Reference Types**

A reference type refers to an object (an instance of a class). Unlike primitive types that hold their values in the memory where the variable is allocated, references do not hold the value of the object they refer to. 

Instead, a reference “points” to an object by storing the memory address where the object is located, a concept referred to as a pointer.

**Objects vs. References**

The reference is a variable that has a name and can be used to access the contents of an object. A reference can be assigned to another reference, passed to a method, or returned from a method. All references are the same size, no matter what their type is.

An object sits on the heap and does not have a name. Therefore, we have no way to access an object except through a reference. Objects come in all different shapes and sizes and consume varying amounts of memory.

An object cannot be assigned to another object, and an object cannot be passed to a method or returned from a method. It is the object that gets garbage collected, not its reference.

Primitives do not have methods declared on them. Reference types can be used to call methods, assuming the reference is not `null`. 

Reference types can be assigned `null`, which means they do not currently refer to an object. Primitive types will give a compiler error if we attempt to assign them `null`. 

**Wrapper Class**

Each primitive type has a wrapper class, which is an object type that corresponds to the primitive.

```java
int primitive = Integer.parseInt("123");   // parses to int primitive type
Integer wrapper = Integer.valueOf("123");  // parser to Integer reference type
```

The first line converts a String to an int primitive. The second converts a String to an Integer wrapper class.

And overloaded method of `valueOf(string)` exits with signature `valueOf(java.lang.String, int)` where second argument is the source radix of the first argument. 

- All of the numeric wrapper classes extend the `Number` class, which means they all come with some useful helper methods: `byteValue()`, `shortValue()`, `intValue()`, `longValue()`, `floatValue()`, and `doubleValue()`. 
- The `Boolean` and `Character` wrapper classes include `booleanValue()` and `charValue()`, respectively.
- These helper methods do their best to convert values but can result in a loss of precision. 

Example,

```java
Double apple = Double.valueOf("200.99");
System.out.println(apple.byteValue());    // -56
System.out.println(apple.intValue());     // 200
System.out.println(apple.doubleValue());  // 200.99
```

**Text Blocks**

Also known as multiline strings.

Text Block can contain two types of whitespaces:

1. Incidental whitespace (Not part of the string, just to ease readability)
2. Essential whitespace (Part of the string)

Imagine a vertical line drawn on the leftmost non-whitespace character in your text block. 

Everything to the left of it is incidental whitespace, and everything to the right is essential whitespace.

Java removes whitespace needed only for code readability (Incidental whitespace), but keeps whitespace needed for content meaning (Essential whitespace).

**Variables and Identifiers**

A variable is a name for a piece of memory that stores data.

An identifier is the name of a variable, method, class, interface, or package. 

A semicolon (`;`) separates statements in Java.

**Local, Instance, and Class variables**

Local variables (inside methods) do not have a default value and must be initialized before use. 

Furthermore, the compiler will report an error if we try to read an uninitialized local variable value. 

We need to remember, the compiler is concerned only if we try to use uninitialized local variables; it doesn’t mind the ones we never use.

<br>
Variables that are not local variables are defined either as instance variables or as class variables.
<br>

An instance variable, often called a field, is a value defined within a specific instance of an object. Two instances could have the same value for an instance variable, but changing the value for one does not modify the other.

Let’s say we have a `Person` class with an instance variable `name` of type `String`. Each instance of the class would have its own value for `name`, such as `Elysia` or `Sarah`. Chaning one name variable value for an instance would not affect the other.
<br>

On the other hand, a class variable is one that is defined on the class level and shared among all instances of the class.

It can even be publicly accessible to classes outside the class and doesn’t require an instance to use.

*Instance and class variables do not require us to initialize them. As soon as we declare these variables, they are given a default value.*

The compiler doesn’t know what value to use and so wants the simplest value it can give the type: `null` for an object, `zero` for the numeric types, and `false` for a `boolean`. 

**Type Inference and `var` keyword**

We have the option of using the keyword `var` instead of the type when declaring local variables under certain conditions.

The formal name of this feature is local variable type inference. We can use this feature only for local variables. 

In Java, `var` is still a specific type defined at compile time (and resolved at compile time). It does not change type at runtime.

The initial value used to determine the type of `var` needs to be part of the same statement. 

That means, we need to initialize the variable declared with `var` keyword in the same line where it is declared. 

Otherwise, the compiler does not know what to make of them i.e. fails to infer the variable type. 

Furthermore, ` var n = null;` is not allowed too. The designers of Java decided it would be better not to allow var for `null` than to have to guess at intent. 

`var` also cannot be used with constructor parameters, method parameters, or instance variables. 

Using `var` in one of these places is a good exam trick to see if we are paying attention. We need to remember that `var` is used only for local variable type inference! So, the following method signature is not legal,

```java
public int addition(var a, var b) {  // DOES NOT COMPILE
   return a + b;
}
```

**`var` Usage Rules:**

- There’s one last rule we should be aware of: `var` is not a reserved word and allowed to be used as an identifier. 
- It is considered a reserved type name. A reserved type name means it cannot be used to define a type, such as a class, interface, or enum. 

**Variable Scope and Tracing Scope**

Identifying blocks and variable scope needs to be second nature for the exam. 

- Rule for of instance variables is easier: they are available as soon as they are defined and last for the entire lifetime of the object itself. 
- The rule for class, aka static, variables is even easier: they go into scope when declared like the other variable types. However, they stay in scope for the entire life of the program.

**Rules on scope:**

- Local variables: In scope from declaration to the end of the block.
- Method parameters: In scope for the duration of the method.
- Instance variables: In scope from declaration until the object is eligible for garbage collection.
- Class variables: In scope from declaration until the program ends.

**Destroying Objects**

Garbage Collector (GC) is a program running inside Java Virtual Machine (JVM)

All Java objects are stored in our program memory’s heap. 

The heap, which is also referred to as the free store, represents a large pool of unused memory allocated to our Java application. If our program keeps instantiating objects and leaving them on the heap, eventually it will run out of memory and crash. 

Garbage collection solves this problem.

**Garbage Collection**

Garbage collection refers to the process of automatically freeing memory on the heap by deleting objects that are no longer reachable in our program.

In Java and other languages, eligible for garbage collection refers to an object’s state of no longer being accessible in a program and therefore able to be garbage collected.

Java includes a built-in method `System.gc();` to help support garbage collection where we can suggest that garbage collection run.

An object will remain on the heap until it is no longer reachable. An object is no longer reachable when one of these two situations occurs:

- The object no longer has any references pointing to it.
- All references to the object have gone out of scope.

When an object becomes orphan in heap memory (no reference pointing to it), it becomes eligible for garbage collection.